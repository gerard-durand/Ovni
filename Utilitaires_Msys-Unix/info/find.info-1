This is /devshop/msys/rt-HEAD/packages/findutils/4.3/doc/find.info,
produced by makeinfo version 4.3 from
/devshop/msys/rt-HEAD/packages/findutils/4.3/doc/find.texi.

INFO-DIR-SECTION Basics
START-INFO-DIR-ENTRY
* Finding files: (find).        Operating on files matching certain criteria.
END-INFO-DIR-ENTRY

INFO-DIR-SECTION Individual utilities
START-INFO-DIR-ENTRY
* find: (find)Invoking find.                    Finding and acting on files.
* locate: (find)Invoking locate.                Finding files in a database.
* updatedb: (find)Invoking updatedb.            Building the locate database.
* xargs: (find)Invoking xargs.                  Operating on many files.
END-INFO-DIR-ENTRY


   This file documents the GNU utilities for finding files that match
certain criteria and performing various operations on them.

   Copyright (C) 1994, 1996, 1998, 2000, 2001, 2003, 2004, 2005 Free
Software Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the Foundation.

File: find.info,  Node: Top,  Next: Introduction,  Up: (dir)

   This file documents the GNU utilities for finding files that match
certain criteria and performing various actions on them.

   This is edition 4.3.0, for `find' version 4.3.0.

* Menu:

* Introduction::                Summary of the tasks this manual describes.
* Finding Files::               Finding files that match certain criteria.
* Actions::                     Doing things to files you have found.
* Databases::                   Maintaining file name databases.
* File Permissions::            How to control access to files.
* Reference::                   Summary of how to invoke the programs.
* Common Tasks::                Solutions to common real-world problems.
* Worked Examples::             Examples demonstrating more complex points.
* Security Considerations::     Security issues relating to findutils.
* Error Messages::              Explanations of some messages you might see.
* Primary Index::               The components of `find' expressions.


File: find.info,  Node: Introduction,  Next: Finding Files,  Prev: Top,  Up: Top

Introduction
************

   This manual shows how to find files that meet criteria you specify,
and how to perform various actions on the files that you find.  The
principal programs that you use to perform these tasks are `find',
`locate', and `xargs'.  Some of the examples in this manual use
capabilities specific to the GNU versions of those programs.

   GNU `find' was originally written by Eric Decker, with enhancements
by David MacKenzie, Jay Plett, and Tim Wood.  GNU `xargs' was
originally written by Mike Rendell, with enhancements by David
MacKenzie.  GNU `locate' and its associated utilities were originally
written by James Woods, with enhancements by David MacKenzie.  The idea
for `find -print0' and `xargs -0' came from Dan Bernstein.  The current
maintainer of GNU findutils (and this manual) is James Youngman.  Many
other people have contributed bug fixes, small improvements, and
helpful suggestions.  Thanks!

   To report a bug in GNU findutils, please use the form on the Savannah
web site at `http://savannah.gnu.org/bugs/?group=findutils'.  Reporting
bugs this way means that you will then be able to track progress in
fixing the problem.

   If you don't have web access, you can also just send mail to the
mailing list.  The mailing list <bug-findutils@gnu.org> carries
discussion of bugs in findutils, questions and answers about the
software and discussion of the development of the programs.  To join
the list, send email to <bug-findutils-request@gnu.org>.

   Please read any relevant sections of this manual before asking for
help on the mailing list.  You may also find it helpful to read the
NON-BUGS section of the `find' manual page.

   If you ask for help on the mailing list, people will be able to help
you much more effectively if you include the following things:

   * The version of the software you are running.  You can find this
     out by running `locate --version'.

   * What you were trying to do

   * The _exact_ command line you used

   * The _exact_ output you got (if this is very long, try to find a
     smaller example which exhibits the same problem)

   * The output you expected to get

* Menu:

* Scope::
* Overview::
* find Expressions::


File: find.info,  Node: Scope,  Next: Overview,  Up: Introduction

Scope
=====

   For brevity, the word "file" in this manual means a regular file, a
directory, a symbolic link, or any other kind of node that has a
directory entry.  A directory entry is also called a "file name".  A
file name may contain some, all, or none of the directories in a path
that leads to the file.  These are all examples of what this manual
calls "file names":

     parser.c
     README
     ./budget/may-94.sc
     fred/.cshrc
     /usr/local/include/termcap.h

   A "directory tree" is a directory and the files it contains, all of
its subdirectories and the files they contain, etc.  It can also be a
single non-directory file.

   These programs enable you to find the files in one or more directory
trees that:

   * have names that contain certain text or match a certain pattern;

   * are links to certain files;

   * were last used during a certain period of time;

   * are within a certain size range;

   * are of a certain type (regular file, directory, symbolic link,
     etc.);

   * are owned by a certain user or group;

   * have certain access permissions;

   * contain text that matches a certain pattern;

   * are within a certain depth in the directory tree;

   * or some combination of the above.

   Once you have found the files you're looking for (or files that are
potentially the ones you're looking for), you can do more to them than
simply list their names.  You can get any combination of the files'
attributes, or process the files in many ways, either individually or
in groups of various sizes.  Actions that you might want to perform on
the files you have found include, but are not limited to:

   * view or edit

   * store in an archive

   * remove or rename

   * change access permissions

   * classify into groups

   This manual describes how to perform each of those tasks, and more.


File: find.info,  Node: Overview,  Next: find Expressions,  Prev: Scope,  Up: Introduction

Overview
========

   The principal programs used for making lists of files that match
given criteria and running commands on them are `find', `locate', and
`xargs'.  An additional command, `updatedb', is used by system
administrators to create databases for `locate' to use.

   `find' searches for files in a directory hierarchy and prints
information about the files it found.  It is run like this:

     find [FILE...] [EXPRESSION]

Here is a typical use of `find'.  This example prints the names of all
files in the directory tree rooted in `/usr/src' whose name ends with
`.c' and that are larger than 100 Kilobytes.
     find /usr/src -name '*.c' -size +100k -print

   Notice that the wildcard must be enclosed in quotes in order to
protect it from expansion by the shell.

   `locate' searches special file name databases for file names that
match patterns.  The system administrator runs the `updatedb' program
to create the databases.  `locate' is run like this:

     locate [OPTION...] PATTERN...

This example prints the names of all files in the default file name
database whose name ends with `Makefile' or `makefile'.  Which file
names are stored in the database depends on how the system
administrator ran `updatedb'.
     locate '*[Mm]akefile'

   The name `xargs', pronounced EX-args, means "combine arguments."
`xargs' builds and executes command lines by gathering together
arguments it reads on the standard input.  Most often, these arguments
are lists of file names generated by `find'.  `xargs' is run like this:

     xargs [OPTION...] [COMMAND [INITIAL-ARGUMENTS]]

The following command searches the files listed in the file `file-list'
and prints all of the lines in them that contain the word `typedef'.
     xargs grep typedef < file-list


File: find.info,  Node: find Expressions,  Prev: Overview,  Up: Introduction

`find' Expressions
==================

   The expression that `find' uses to select files consists of one or
more "primaries", each of which is a separate command line argument to
`find'.  `find' evaluates the expression each time it processes a file.
An expression can contain any of the following types of primaries:

"options"
     affect overall operation rather than the processing of a specific
     file;

"tests"
     return a true or false value, depending on the file's attributes;

"actions"
     have side effects and return a true or false value; and

"operators"
     connect the other arguments and affect when and whether they are
     evaluated.

   You can omit the operator between two primaries; it defaults to
`-and'.  *Note Combining Primaries With Operators::, for ways to
connect primaries into more complex expressions.  If the expression
contains no actions other than `-prune', `-print' is performed on all
files for which the entire expression is true (*note Print File Name::).

   Options take effect immediately, rather than being evaluated for each
file when their place in the expression is reached.  Therefore, for
clarity, it is best to place them at the beginning of the expression.

   Many of the primaries take arguments, which immediately follow them
in the next command line argument to `find'.  Some arguments are file
names, patterns, or other strings; others are numbers.  Numeric
arguments can be specified as

`+N'
     for greater than N,

`-N'
     for less than N,

`N'
     for exactly N.


File: find.info,  Node: Finding Files,  Next: Actions,  Prev: Introduction,  Up: Top

Finding Files
*************

   By default, `find' prints to the standard output the names of the
files that match the given criteria.  *Note Actions::, for how to get
more information about the matching files.

* Menu:

* Name::
* Links::
* Time::
* Size::
* Type::
* Owner::
* Permissions::
* Contents::
* Directories::
* Filesystems::
* Combining Primaries With Operators::


File: find.info,  Node: Name,  Next: Links,  Up: Finding Files

Name
====

   Here are ways to search for files whose name matches a certain
pattern.  *Note Shell Pattern Matching::, for a description of the
PATTERN arguments to these tests.

   Each of these tests has a case-sensitive version and a
case-insensitive version, whose name begins with `i'.  In a
case-insensitive comparison, the patterns `fo*' and `F??' match the
file names `Foo', `FOO', `foo', `fOo', etc.

* Menu:

* Base Name Patterns::
* Full Name Patterns::
* Fast Full Name Search::
* Shell Pattern Matching::      Wildcards used by these programs.


File: find.info,  Node: Base Name Patterns,  Next: Full Name Patterns,  Up: Name

Base Name Patterns
------------------

 - Test: -name pattern
 - Test: -iname pattern
     True if the base of the file name (the path with the leading
     directories removed) matches shell pattern PATTERN.  For `-iname',
     the match is case-insensitive.(1) To ignore a whole directory
     tree, use `-prune' (*note Directories::).  As an example, to find
     Texinfo source files in `/usr/local/doc':

          find /usr/local/doc -name '*.texi'

     Notice that the wildcard must be enclosed in quotes in order to
     protect it from expansion by the shell.

     As of findutils version 4.2.2, patterns for `-name' and `-iname'
     will match a file name with a leading `.'.  For example the
     command `find /tmp -name \*bar' will match the file
     `/tmp/.foobar'.  Braces within the pattern (`{}') are not
     considered to be special (that is, `find . -name 'foo{1,2}''
     matches a file named `foo{1,2}', not the files `foo1' and `foo2'.

   ---------- Footnotes ----------

   (1) Because we need to perform case-insensitive matching, the GNU
fnmatch implementation is always used; if the C library includes the GNU
implementation, we use that and otherwise we use the one from gnulib


File: find.info,  Node: Full Name Patterns,  Next: Fast Full Name Search,  Prev: Base Name Patterns,  Up: Name

Full Name Patterns
------------------

 - Test: -wholename pattern
 - Test: -iwholename pattern
     True if the entire file name, starting with the command line
     argument under which the file was found, matches shell pattern
     PATTERN.  For `-iwholename', the match is case-insensitive.  To
     ignore a whole directory tree, use `-prune' rather than checking
     every file in the tree (*note Directories::).  The "entire file
     name" as used by `find' starts with the starting-point specified
     on the command line, and is not converted to an absolute pathname,
     so for example `cd /; find tmp -wholename /tmp' will never match
     anything.

 - Test: -path pattern
 - Test: -ipath pattern
     These tests are deprecated, but work as for `-wholename' and
     `-iwholename', respectively.  The `-ipath' test is a GNU
     extension, but `-path' is also provided by HP-UX `find'.

 - Test: -regex expr
 - Test: -iregex expr
     True if the entire file name matches regular expression EXPR.
     This is a match on the whole path, not a search.  For example, to
     match a file named `./fubar3', you can use the regular expression
     `.*bar.' or `.*b.*3', but not `f.*r3'.  *Note Syntax of Regular
     Expressions: (emacs)Regexps, for a description of the syntax of
     regular expressions.  For `-iregex', the match is
     case-insensitive.  There are several varieties of regular
     expressions; by default this test uses POSIX basic regular
     expressions, but this can be changed with the option `-regextype'.

 - Option: -regextype name
     This option controls the variety of regular expression syntax
     understood by the `-regex' and `-iregex' tests.  This option is
     positional; that is, it only affects regular expressions which
     occur later in the command line.  If this option is not given, GNU
     Emacs regular expressions are assumed.  Currently-implemented types
     are

    `emacs'
          Regular expressions compatible with GNU Emacs; this is also
          the default behaviour if this option is not used.

    `posix-awk'
          Regular expressions compatible with the POSIX awk command
          (not GNU awk)

    `posix-basic'
          POSIX Basic Regular Expressions.

    `posix-egrep'
          Regular expressions compatible with the POSIX egrep command

    `posix-extended'
          POSIX Extended Regular Expressions

     *Note Regular Expressions:: for more information on the regular
     expression dialects understood by GNU findutils.



File: find.info,  Node: Fast Full Name Search,  Next: Shell Pattern Matching,  Prev: Full Name Patterns,  Up: Name

Fast Full Name Search
---------------------

   To search for files by name without having to actually scan the
directories on the disk (which can be slow), you can use the `locate'
program.  For each shell pattern you give it, `locate' searches one or
more databases of file names and displays the file names that contain
the pattern.  *Note Shell Pattern Matching::, for details about shell
patterns.

   If a pattern is a plain string--it contains no
metacharacters--`locate' displays all file names in the database that
contain that string.  If a pattern contains metacharacters, `locate'
only displays file names that match the pattern exactly.  As a result,
patterns that contain metacharacters should usually begin with a `*',
and will most often end with one as well.  The exceptions are patterns
that are intended to explicitly match the beginning or end of a file
name.

   If you only want `locate' to match against the last component of the
file names (the "base name" of the files) you can use the `--basename'
option.  The opposite behaviour is the default, but can be selected
explicitly by using the option `--wholename'.

   The command
     locate PATTERN

   is almost equivalent to
     find DIRECTORIES -name PATTERN

   where DIRECTORIES are the directories for which the file name
databases contain information.  The differences are that the `locate'
information might be out of date, and that `locate' handles wildcards
in the pattern slightly differently than `find' (*note Shell Pattern
Matching::).

   The file name databases contain lists of files that were on the
system when the databases were last updated.  The system administrator
can choose the file name of the default database, the frequency with
which the databases are updated, and the directories for which they
contain entries.

   Here is how to select which file name databases `locate' searches.
The default is system-dependent.

`--database=PATH'
`-d PATH'
     Instead of searching the default file name database, search the
     file name databases in PATH, which is a colon-separated list of
     database file names.  You can also use the environment variable
     `LOCATE_PATH' to set the list of database files to search.  The
     option overrides the environment variable if both are used.


File: find.info,  Node: Shell Pattern Matching,  Prev: Fast Full Name Search,  Up: Name

Shell Pattern Matching
----------------------

   `find' and `locate' can compare file names, or parts of file names,
to shell patterns.  A "shell pattern" is a string that may contain the
following special characters, which are known as "wildcards" or
"metacharacters".

   You must quote patterns that contain metacharacters to prevent the
shell from expanding them itself.  Double and single quotes both work;
so does escaping with a backslash.

`*'
     Matches any zero or more characters.

`?'
     Matches any one character.

`[STRING]'
     Matches exactly one character that is a member of the string
     STRING.  This is called a "character class".  As a shorthand,
     STRING may contain ranges, which consist of two characters with a
     dash between them.  For example, the class `[a-z0-9_]' matches a
     lowercase letter, a number, or an underscore.  You can negate a
     class by placing a `!' or `^' immediately after the opening
     bracket.  Thus, `[^A-Z@]' matches any character except an
     uppercase letter or an at sign.

`\'
     Removes the special meaning of the character that follows it.  This
     works even in character classes.

   In the `find' tests that do shell pattern matching (`-name',
`-wholename', etc.), wildcards in the pattern will match a `.'  at the
beginning of a file name.  This is also the case for `locate'.  Thus,
`find -name '*macs'' will match a file named `.emacs', as will `locate
'*macs''.

   Slash characters have no special significance in the shell pattern
matching that `find' and `locate' do, unlike in the shell, in which
wildcards do not match them.  Therefore, a pattern `foo*bar' can match
a file name `foo3/bar', and a pattern `./sr*sc' can match a file name
`./src/misc'.

   If you want to locate some files with the `locate' command but don't
need to see the full list you can use the `--limit' option to see just
a small number of results, or the `--count' option to display only the
total number of matches.


File: find.info,  Node: Links,  Next: Time,  Prev: Name,  Up: Finding Files

Links
=====

   There are two ways that files can be linked together.  "Symbolic
links" are a special type of file whose contents are a portion of the
name of another file.  "Hard links" are multiple directory entries for
one file; the file names all have the same index node ("inode") number
on the disk.

* Menu:

* Symbolic Links::
* Hard Links::


File: find.info,  Node: Symbolic Links,  Next: Hard Links,  Up: Links

Symbolic Links
--------------

   Symbolic links are names that reference other files.  GNU `find'
will handle symbolic links in one of two ways; firstly, it can
dereference the links for you - this means that if it comes across a
symbolic link, it examines the file that the link points to, in order
to see if it matches the criteria you have specified.  Secondly, it can
check the link itself in case you might be looking for the actual link.
If the file that the symbolic link points to is also within the
directory hierarchy you are searching with the `find' command, you may
not see a great deal of difference between these two alternatives.

   By default, `find' examines symbolic links themselves when it finds
them (and, if it later comes across the linked-to file, it will examine
that, too).  If you would prefer `find' to dereference the links and
examine the file that each link points to, specify the `-L' option to
`find'.  You can explicitly specify the default behaviour by using the
`-P' option.  The `-H' option is a half-way-between option which
ensures that any symbolic links listed on the command line are
dereferenced, but other symbolic links are not.

   Symbolic links are different to "hard links" in the sense that you
need permissions upon the linked-to file in order to be able to
dereference the link.  This can mean that even if you specify the `-L'
option, `find' may not be able to determine the properties of the file
that the link points to (because you don't have sufficient
permissions).  In this situation, `find' uses the properties of the
link itself.  This also occurs if a symbolic link exists but points to
a file that is missing.

   The options controlling the behaviour of `find' with respect to
links are as follows :-

`-P'
     `find' does not dereference symbolic links at all.  This is the
     default behaviour.  This option must be specified before any of the
     file names on the command line.

`-H'
     `find' does not dereference symbolic links (except in the case of
     file names on the command line, which are dereferenced).  If a
     symbolic link cannot be dereferenced, the information for the
     symbolic link itself is used.  This option must be specified
     before any of the file names on the command line.

`-L'
     `find' dereferences symbolic links where possible, and where this
     is not possible it uses the properties of the symbolic link itself.
     This option must be specified before any of the file names on the
     command line.  Use of this option also implies the same behaviour
     as the `-noleaf' option.  If you later use the `-H' or `-P'
     options, this does not turn off `-noleaf'.

`-follow'
     This option forms part of the "expression" and must be specified
     after the file names, but it is otherwise equivalent to `-L'.  The
     `-follow' option affects only those tests which appear after it on
     the command line.  This option is deprecated.  Where possible, you
     should use `-L' instead.

   The following differences in behavior occur when the `-L' option is
used:

   * `find' follows symbolic links to directories when searching
     directory trees.

   * `-lname' and `-ilname' always return false (unless they happen to
     match broken symbolic links).

   * `-type' reports the types of the files that symbolic links point
     to.  This means that in combination with `-L', `-type l' will be
     true only for broken symbolic links.  To check for symbolic links
     when `-L' has been specified, use `-xtype l'.

   * Implies `-noleaf' (*note Directories::).

   If the `-L' option or the `-H' option is used, the file names used
as arguments to `-newer', `-anewer', and `-cnewer' are dereferenced and
the timestamp from the pointed-to file is used instead (if possible -
otherwise the timestamp from the symbolic link is used).

 - Test: -lname pattern
 - Test: -ilname pattern
     True if the file is a symbolic link whose contents match shell
     pattern PATTERN.  For `-ilname', the match is case-insensitive.
     *Note Shell Pattern Matching::, for details about the PATTERN
     argument.  If the `-L' option is in effect, this test will always
     return false for symbolic links unless they are broken.  So, to
     list any symbolic links to `sysdep.c' in the current directory and
     its subdirectories, you can do:

          find . -lname '*sysdep.c'


File: find.info,  Node: Hard Links,  Prev: Symbolic Links,  Up: Links

Hard Links
----------

   Hard links allow more than one name to refer to the same file.  To
find all the names which refer to the same file as NAME, use `-samefile
NAME'.  If you are not using the `-L' option, you can confine your
search to one filesystem using the `-xdev' option.  This is useful
because hard links cannot point outside a single filesystem, so this
can cut down on needless searching.

   If the `-L' option is in effect, and NAME is in fact a symbolic
link, the symbolic link will be dereferenced.  Hence you are searching
for other links (hard or symbolic) to the file pointed to by NAME.  If
`-L' is in effect but NAME is not itself a symbolic link, other
symbolic links to the file NAME will be matched.

   You can also search for files by inode number.  This can occasionally
be useful in diagnosing problems with filesystems for example, because
`fsck' tends to print inode numbers.  Inode numbers also occasionally
turn up in log messages for some types of software, and are used to
support the `ftok()' library function.

   You can learn a file's inode number and the number of links to it by
running `ls -li' or `find -ls'.

   You can search for hard links to inode number NUM by using `-inum
NUM'. If there are any filesystem mount points below the directory
where you are starting the search, use the `-xdev' option unless you
are also using the `-L' option.  Using `-xdev' this saves needless
searching, since hard links to a file must be on the same filesystem.
*Note Filesystems::.

 - Test: -samefile NAME
     File is a hard link to the same inode as NAME.  If the `-L' option
     is in effect, symbolic links to the same file as NAME points to
     are also matched.

 - Test: -inum n
     File has inode number N.  The `+' and `-' qualifiers also work,
     though these are rarely useful.  Much of the time it is easier to
     use `-samefile' rather than this option.

   You can also search for files that have a certain number of links,
with `-links'.  Directories normally have at least two hard links;
their `.' entry is the second one.  If they have subdirectories, each
of those also has a hard link called `..' to its parent directory.  The
`.' and `..' directory entries are not normally searched unless they
are mentioned on the `find' command line.

 - Test: -links n
     File has N hard links.

 - Test: -links +n
     File has more than N hard links.

 - Test: -links -n
     File has fewer than N hard links.


File: find.info,  Node: Time,  Next: Size,  Prev: Links,  Up: Finding Files

Time
====

   Each file has three time stamps, which record the last time that
certain operations were performed on the file:

  1. access (read the file's contents)

  2. change the status (modify the file or its attributes)

  3. modify (change the file's contents)

   There is no timestamp that indicates when a file was _created_.

   You can search for files whose time stamps are within a certain age
range, or compare them to other time stamps.

* Menu:

* Age Ranges::
* Comparing Timestamps::


File: find.info,  Node: Age Ranges,  Next: Comparing Timestamps,  Up: Time

Age Ranges
----------

   These tests are mainly useful with ranges (`+N' and `-N').

 - Test: -atime n
 - Test: -ctime n
 - Test: -mtime n
     True if the file was last accessed (or its status changed, or it
     was modified) N*24 hours ago.  The number of 24-hour periods since
     the file's timestamp is always rounded down; therefore 0 means
     "less than 24 hours ago", 1 means "between 24 and 48 hours ago",
     and so forth.

 - Test: -amin n
 - Test: -cmin n
 - Test: -mmin n
     True if the file was last accessed (or its status changed, or it
     was modified) N minutes ago.  These tests provide finer granularity
     of measurement than `-atime' et al., but rounding is done in a
     similar way.  For example, to list files in `/u/bill' that were
     last read from 2 to 6 minutes ago:

          find /u/bill -amin +2 -amin -6

 - Option: -daystart
     Measure times from the beginning of today rather than from 24 hours
     ago.  So, to list the regular files in your home directory that
     were modified yesterday, do

          find ~ -daystart -type f -mtime 1

     The `-daystart' option is unlike most other options in that it has
     an effect on the way that other tests are performed.  The affected
     tests are `-amin', `-cmin', `-mmin', `-atime', `-ctime' and
     `-mtime'.  The `-daystart' option only affects the behaviour of
     any tests which appear after it on the command line.


File: find.info,  Node: Comparing Timestamps,  Prev: Age Ranges,  Up: Time

Comparing Timestamps
--------------------

   As an alternative to comparing timestamps to the current time, you
can compare them to another file's timestamp.  That file's timestamp
could be updated by another program when some event occurs.  Or you
could set it to a particular fixed date using the `touch' command.  For
example, to list files in `/usr' modified after February 1 of the
current year:

     touch -t 02010000 /tmp/stamp$$
     find /usr -newer /tmp/stamp$$
     rm -f /tmp/stamp$$

 - Test: -anewer file
 - Test: -cnewer file
 - Test: -newer file
     True if the file was last accessed (or its status changed, or it
     was modified) more recently than FILE was modified.  These tests
     are affected by `-follow' only if `-follow' comes before them on
     the command line.  *Note Symbolic Links::, for more information on
     `-follow'.  As an example, to list any files modified since
     `/bin/sh' was last modified:

          find . -newer /bin/sh

 - Test: -used n
     True if the file was last accessed N days after its status was
     last changed.  Useful for finding files that are not being used,
     and could perhaps be archived or removed to save disk space.


File: find.info,  Node: Size,  Next: Type,  Prev: Time,  Up: Finding Files

Size
====

 - Test: -size n[bckwMG]
     True if the file uses N units of space, rounding up.  The units
     are 512-byte blocks by default, but they can be changed by adding a
     one-character suffix to N:

    `b'
          512-byte blocks (never 1024)

    `c'
          bytes

    `k'
          kilobytes (1024 bytes)

    `w'
          2-byte words

    `M'
          Megabytes (units of 1048576 bytes)

    `G'
          Gigabytes (units of 1073741824 bytes)

     The `b' suffix always considers blocks to be 512 bytes.  This is
     not affected by the setting (or non-setting) of the POSIXLY_CORRECT
     environment variable.  This behaviour is different to the
     behaviour of the `-ls' action).  If you want to use 1024-byte
     units, use the `k' suffix instead.

     The number can be prefixed with a `+' or a `-'.  A plus sign
     indicates that the test should succeed if the file uses at least N
     units of storage (a common use of this test) and a minus sign
     indicates that the test should succeed if the file uses less than
     N units of storage.  There is no `=' prefix, because that's the
     default anyway.

     The size does not count indirect blocks, but it does count blocks
     in sparse files that are not actually allocated.  In other words,
     it's consistent with the result you get for `ls -l' or `wc -c'.
     This handling of sparse files differs from the output of the `%k'
     and `%b' format specifiers for the `-printf' predicate.


 - Test: -empty
     True if the file is empty and is either a regular file or a
     directory.  This might help determine good candidates for
     deletion.  This test is useful with `-depth' (*note Directories::)
     and `-delete' (*note Single File::).


File: find.info,  Node: Type,  Next: Owner,  Prev: Size,  Up: Finding Files

Type
====

 - Test: -type c
     True if the file is of type C:

    `b'
          block (buffered) special

    `c'
          character (unbuffered) special

    `d'
          directory

    `p'
          named pipe (FIFO)

    `f'
          regular file

    `l'
          symbolic link; if `-L' is in effect, this is true only for
          broken symbolic links.  If you want to search for symbolic
          links when `-L' is in effect, use `-xtype' instead of `-type'.

    `s'
          socket

    `D'
          door (Solaris)

 - Test: -xtype c
     This test behaves the same as `-type' unless the file is a
     symbolic link.  If the file is a symbolic link, the result is as
     follows (in the table below, `X' should be understood to represent
     any letter except `l'):

    ``-P -xtype l''
          True if the symbolic link is broken

    ``-P -xtype X''
          True if the (ultimate) target file is of type `X'.

    ``-L -xtype l''
          Always true

    ``-L -xtype X''
          False unless the symbolic link is broken

     In other words, for symbolic links, `-xtype' checks the type of
     the file that `-type' does not check.

     The `-H' option also affects the behaviour of `-xtype'.  When `-H'
     is in effect, `-xtype' behaves as if `-L' had been specified when
     examining files listed on the command line, and as if `-P' had
     been specified otherwise.  If neither `-H' nor `-L' was specified,
     `-xtype' behaves as if `-P' had been specified.

     *Note Symbolic Links::, for more information on `-follow' and `-L'.


File: find.info,  Node: Owner,  Next: Permissions,  Prev: Type,  Up: Finding Files

Owner
=====

 - Test: -user uname
 - Test: -group gname
     True if the file is owned by user UNAME (belongs to group GNAME).
     A numeric ID is allowed.

 - Test: -uid n
 - Test: -gid n
     True if the file's numeric user ID (group ID) is N.  These tests
     support ranges (`+N' and `-N'), unlike `-user' and `-group'.

 - Test: -nouser
 - Test: -nogroup
     True if no user corresponds to the file's numeric user ID (no group
     corresponds to the numeric group ID).  These cases usually mean
     that the files belonged to users who have since been removed from
     the system.  You probably should change the ownership of such
     files to an existing user or group, using the `chown' or `chgrp'
     program.


File: find.info,  Node: Permissions,  Next: Contents,  Prev: Owner,  Up: Finding Files

Permissions
===========

   *Note File Permissions::, for information on how file permissions are
structured and how to specify them.

   Four tests determine what users can do with files.  These are
`-readable', `-writable', `-executable' and `-perm'.  The first three
tests ask the operating system if the current user can perform the
relevant operation on a file, while `-perm' just examines the file's
mode.  The file mode may give a misleading impression of what the user
can actually do, because the file may have an access control list, or
exist on a read-only filesystem, for example.  Of these four tests
though, only `-perm' is specified by the POSIX standard.

   The `-readable', `-writable' and `-executable' tests are implemented
via the `access' system call.  This is implemented within the operating
system itself.  If the file being considered is on an NFS filesystem,
the remote system may allow or forbid read or write operations for
reasons of which the NFS client cannot take account.  This includes
user-ID mapping, either in the general sense or the more restricted
sense in which remote superusers are treated by the NFS server as if
they are the local user `nobody' on the NFS server.

   None of the tests in this section should be used to verify that a
user is authorised to perform any operation (on the file being tested or
any other file) because of the possibility of a race condition.  That
is, the situation may change between the test and an action being taken
on the basis of the result of that test.

 - Test: -readable
     True if the file can be read by the invoking user.

 - Test: -writable
     True if the file can be written by the invoking user.  This is an
     in-principle check, and other things may prevent a successful write
     operation; for example, the filesystem might be full.

 - Test: -executable
     True if the file can be executed by the invoking user.

 - Test: -perm mode
     True if the file's permissions are exactly MODE, which can be
     numeric or symbolic.

     If MODE starts with `-', true if _all_ of the permissions set in
     MODE are set for the file; permissions not set in MODE are ignored.

     If MODE starts with `/', true if _any_ of the permissions set in
     MODE are set for the file; permissions not set in MODE are ignored.
     This is a GNU extension.

     If you don't use the `/' or `-' form with a symbolic mode string,
     you may have to specify a rather complex mode string.  For example
     `-perm g=w' will only match files which have mode 0020 (that is,
     ones for which group write permission is the only permission set).
     It is more likely that you will want to use the `/' or `-' forms,
     for example `-perm -g=w', which matches any file with group write
     permission.

    `-perm 664'
          Match files which have read and write permission for their
          owner, and group, but which the rest of the world can read
          but not write to.  Files which meet these criteria but have
          other permissions bits set (for example if someone can
          execute the file) will not be matched.

    `-perm -664'
          Match files which have read and write permission for their
          owner, and group, but which the rest of the world can read
          but not write to, without regard to the presence of any extra
          permission bits (for example the executable bit).  This will
          match a file which has mode 0777, for example.

    `-perm /222'
          Match files which are writable by somebody (their owner, or
          their group, or anybody else).

    `-perm /022'
          Match files which are writable by either their owner or their
          group.  The files don't have to be writable by both the owner
          and group to be matched; either will do.

    `-perm /g+w,o+w'
          As above.

    `-perm /g=w,o=w'
          As above

    `-perm -022'
          Search for files which are writable by both their owner and
          their group.

    `-perm -444 -perm /222 ! -perm /111'
          Search for files which are readable for everybody, have at
          least one write bit set (i.e. somebody can write to them),
          but which cannot be executed by anybody.  Note that in some
          shells the `!' must be escaped;.

    `-perm -a+r -perm /a+w ! -perm /a+x'
          As above.

    `-perm -g+w,o+w'
          As above.

          If you specify `-perm /000' or `-perm /mode' where the
          symbolic mode `mode' has no bits set, the test currently
          matches no files.  This differs from the behaviour of `-perm
          -000', which matches all files.  The behaviour of `-perm
          /000' will be changed to be consistent with the behaviour of
          `-perm -000'.  The change will probably be made in early 2006.



File: find.info,  Node: Contents,  Next: Directories,  Prev: Permissions,  Up: Finding Files

Contents
========

   To search for files based on their contents, you can use the `grep'
program.  For example, to find out which C source files in the current
directory contain the string `thing', you can do:

     grep -l thing *.[ch]

   If you also want to search for the string in files in subdirectories,
you can combine `grep' with `find' and `xargs', like this:

     find . -name '*.[ch]' | xargs grep -l thing

   The `-l' option causes `grep' to print only the names of files that
contain the string, rather than the lines that contain it.  The string
argument (`thing') is actually a regular expression, so it can contain
metacharacters.  This method can be refined a little by using the `-r'
option to make `xargs' not run `grep' if `find' produces no output, and
using the `find' action `-print0' and the `xargs' option `-0' to avoid
misinterpreting files whose names contain spaces:

     find . -name '*.[ch]' -print0 | xargs -r -0 grep -l thing

   For a fuller treatment of finding files whose contents match a
pattern, see the manual page for `grep'.


File: find.info,  Node: Directories,  Next: Filesystems,  Prev: Contents,  Up: Finding Files

Directories
===========

   Here is how to control which directories `find' searches, and how it
searches them.  These two options allow you to process a horizontal
slice of a directory tree.

 - Option: -maxdepth levels
     Descend at most LEVELS (a non-negative integer) levels of
     directories below the command line arguments.  `-maxdepth 0' means
     only apply the tests and actions to the command line arguments.

 - Option: -mindepth levels
     Do not apply any tests or actions at levels less than LEVELS (a
     non-negative integer).  `-mindepth 1' means process all files
     except the command line arguments.

 - Option: -depth
     Process each directory's contents before the directory itself.
     Doing this is a good idea when producing lists of files to archive
     with `cpio' or `tar'.  If a directory does not have write
     permission for its owner, its contents can still be restored from
     the archive since the directory's permissions are restored after
     its contents.

 - Option: -d
     This is a deprecated synonym for `-depth', for compatibility with
     Mac OS X, FreeBSD and OpenBSD.  The `-depth' option is a POSIX
     feature, so it is better to use that.

 - Action: -prune
     If the file is a directory, do not descend into it.  The result is
     true.  For example, to skip the directory `src/emacs' and all
     files and directories under it, and print the names of the other
     files found:

          find . -wholename './src/emacs' -prune -o -print

     The above command will not print `./src/emacs' among its list of
     results.  This however is not due to the effect of the `-prune'
     action (which only prevents further descent, it doesn't make sure
     we ignore that item).  Instead, this effect is due to the use of
     `-o'.  Since the left hand side of the "or" condition has
     succeeded for `./src/emacs', it is not necessary to evaluate the
     right-hand-side (`-print') at all for this particular file.  If
     you wanted to print that directory name you could use either an
     extra `-print' action:

          find . -wholename './src/emacs' -prune -print -o -print

     or use the comma operator:

          find . -wholename './src/emacs' -prune , -print

     If the `-depth' option is in effect, the subdirectories will have
     already been visited in any case.  Hence `-prune' has no effect
     and returns false.

 - Action: -quit
     Exit immediately (with return value zero if no errors have
     occurred).  No child processes will be left running, but no more
     files specified on the command line will be processed.  For
     example, `find /tmp/foo /tmp/bar -print -quit' will print only
     `/tmp/foo'.  Any command lines which have been built by `-exec ...
     \+' or `-execdir ... \+' are invoked before the program is
     executed.

 - Option: -noleaf
     Do not optimize by assuming that directories contain 2 fewer
     subdirectories than their hard link count.  This option is needed
     when searching filesystems that do not follow the Unix
     directory-link convention, such as CD-ROM or MS-DOS filesystems or
     AFS volume mount points.  Each directory on a normal Unix
     filesystem has at least 2 hard links: its name and its `.'  entry.
     Additionally, its subdirectories (if any) each have a `..'  entry
     linked to that directory.  When `find' is examining a directory,
     after it has statted 2 fewer subdirectories than the directory's
     link count, it knows that the rest of the entries in the directory
     are non-directories ("leaf" files in the directory tree).  If only
     the files' names need to be examined, there is no need to stat
     them; this gives a significant increase in search speed.

 - Option: -ignore_readdir_race
     If a file disappears after its name has been read from a directory
     but before `find' gets around to examining the file with `stat',
     don't issue an error message.  If you don't specify this option, an
     error message will be issued.  This option can be useful in system
     scripts (cron scripts, for example) that examine areas of the
     filesystem that change frequently (mail queues, temporary
     directories, and so forth), because this scenario is common for
     those sorts of directories.  Completely silencing error messages
     from `find' is undesirable, so this option neatly solves the
     problem.  There is no way to search one part of the filesystem
     with this option on and part of it with this option off, though.
     When this option is turned on and find discovers that one of the
     start-point files specified on the command line does not exist, no
     error message will be issued.


 - Option: -noignore_readdir_race
     This option reverses the effect of the `-ignore_readdir_race'
     option.


File: find.info,  Node: Filesystems,  Next: Combining Primaries With Operators,  Prev: Directories,  Up: Finding Files

Filesystems
===========

   A "filesystem" is a section of a disk, either on the local host or
mounted from a remote host over a network.  Searching network
filesystems can be slow, so it is common to make `find' avoid them.

   There are two ways to avoid searching certain filesystems.  One way
is to tell `find' to only search one filesystem:

 - Option: -xdev
 - Option: -mount
     Don't descend directories on other filesystems.  These options are
     synonyms.

   The other way is to check the type of filesystem each file is on, and
not descend directories that are on undesirable filesystem types:

 - Test: -fstype type
     True if the file is on a filesystem of type TYPE.  The valid
     filesystem types vary among different versions of Unix; an
     incomplete list of filesystem types that are accepted on some
     version of Unix or another is:
          ext2 ext3 proc sysfs ufs 4.2 4.3 nfs tmp mfs S51K S52K
     You can use `-printf' with the `%F' directive to see the types of
     your filesystems.  The `%D' directive shows the device number.
     *Note Print File Information::.  `-fstype' is usually used with
     `-prune' to avoid searching remote filesystems (*note
     Directories::).


File: find.info,  Node: Combining Primaries With Operators,  Prev: Filesystems,  Up: Finding Files

Combining Primaries With Operators
==================================

   Operators build a complex expression from tests and actions.  The
operators are, in order of decreasing precedence:

`( EXPR )'
     Force precedence.  True if EXPR is true.

`! EXPR'
`-not EXPR'
     True if EXPR is false.  In some shells, it is necessary to protect
     the `!' from shell interpretation by quoting it.

`EXPR1 EXPR2'
`EXPR1 -a EXPR2'
`EXPR1 -and EXPR2'
     And; EXPR2 is not evaluated if EXPR1 is false.

`EXPR1 -o EXPR2'
`EXPR1 -or EXPR2'
     Or; EXPR2 is not evaluated if EXPR1 is true.

`EXPR1 , EXPR2'
     List; both EXPR1 and EXPR2 are always evaluated.  True if EXPR2 is
     true.  The value of EXPR1 is discarded.  This operator lets you do
     multiple independent operations on one traversal, without
     depending on whether other operations succeeded.  The two
     operations EXPR1 and EXPR2 are not always fully independent, since
     EXPR1 might have side effects like touching or deleting files, or
     it might use `-prune' which would also affect EXPR2.

   `find' searches the directory tree rooted at each file name by
evaluating the expression from left to right, according to the rules of
precedence, until the outcome is known (the left hand side is false for
`-and', true for `-or'), at which point `find' moves on to the next
file name.

   There are two other tests that can be useful in complex expressions:

 - Test: -true
     Always true.

 - Test: -false
     Always false.


File: find.info,  Node: Actions,  Next: Databases,  Prev: Finding Files,  Up: Top

Actions
*******

   There are several ways you can print information about the files that
match the criteria you gave in the `find' expression.  You can print
the information either to the standard output or to a file that you
name.  You can also execute commands that have the file names as
arguments.  You can use those commands as further filters to select
files.

* Menu:

* Print File Name::
* Print File Information::
* Run Commands::
* Delete Files::
* Adding Tests::


File: find.info,  Node: Print File Name,  Next: Print File Information,  Up: Actions

Print File Name
===============

 - Action: -print
     True; print the entire file name on the standard output, followed
     by a newline.  If there is the faintest possibility that one of
     the files for which you are searching might contain a newline, you
     should use `-print0' instead.

 - Action: -fprint file
     True; print the entire file name into file FILE, followed by a
     newline.  If FILE does not exist when `find' is run, it is
     created; if it does exist, it is truncated to 0 bytes.  The named
     output file is always created, even if no output is sent to it.
     The file names `/dev/stdout' and `/dev/stderr' are handled
     specially; they refer to the standard output and standard error
     output, respectively.

     If there is the faintest possibility that one of the files for
     which you are searching might contain a newline, you should use
     `-fprint0' instead.

